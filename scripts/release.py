#!/usr/bin/env uv run --with tomli

from __future__ import annotations

import json
import os
import shutil
import subprocess
import sys
import tarfile
import textwrap
import webbrowser
import zipfile
from pathlib import Path
from tempfile import TemporaryDirectory

try:  # Python 3.11+
    import tomllib  # type: ignore[attr-defined]
except ModuleNotFoundError:  # pragma: no cover - fallback for older Python
    import tomli as tomllib  # type: ignore[no-redef]


ROOT = Path(__file__).resolve().parents[1]
DIST_DIR = ROOT / "target" / "dist"


def extend_path() -> None:
    extras = [
        Path.home() / ".cargo" / "bin",
        Path.home() / ".local" / "bin",
        Path.home() / ".local" / "bin" / "bin",
    ]
    current = os.environ.get("PATH", "")
    paths = current.split(os.pathsep) if current else []
    updated = paths[:]
    for extra in extras:
        extra_str = str(extra)
        if extra.exists() and extra_str not in paths:
            updated.append(extra_str)
    if updated != paths:
        os.environ["PATH"] = os.pathsep.join(updated)


def read_manifest() -> dict:
    manifest_path = ROOT / "Cargo.toml"
    try:
        return tomllib.loads(manifest_path.read_text())
    except FileNotFoundError as exc:
        sys.exit(f"Unable to read Cargo.toml: {exc}")


def collect_targets(manifest: dict) -> list[str]:
    metadata = manifest.get("workspace", {}).get("metadata", {})
    targets = metadata.get("dist", {}).get("targets")
    if not targets:
        sys.exit(
            "No release targets found in workspace.metadata.dist.targets; "
            "add them to Cargo.toml or edit scripts/release.py."
        )
    return targets


def collect_binaries(manifest: dict) -> list[str]:
    bins = [entry["name"] for entry in manifest.get("bin", []) if "name" in entry]
    if bins:
        return bins

    package_name = manifest["package"]["name"]
    metadata_raw = subprocess.run(
        ["cargo", "metadata", "--format-version", "1", "--no-deps"],
        check=True,
        capture_output=True,
        text=True,
    ).stdout
    metadata = json.loads(metadata_raw)
    for package in metadata.get("packages", []):
        if package.get("name") != package_name:
            continue
        detected = [
            target["name"]
            for target in package.get("targets", [])
            if "bin" in target.get("kind", [])
        ]
        if detected:
            return detected

    sys.exit(f"No binary targets found for package '{package_name}'.")


def ensure_tools_available() -> None:
    for cmd in ("cargo", "rustup", "gh", "git"):
        if shutil.which(cmd) is None:
            sys.exit(
                f"Required command '{cmd}' is not available in PATH. "
                "Install the missing tool and re-run the script."
            )


def run(cmd: list[str], **kwargs) -> subprocess.CompletedProcess:
    print(f"â†’ {' '.join(cmd)}")
    return subprocess.run(cmd, check=True, **kwargs)


def current_commit() -> str:
    return (
        subprocess.run(
            ["git", "rev-parse", "HEAD"],
            check=True,
            capture_output=True,
            text=True,
        )
        .stdout.strip()
    )


def get_release(tag: str) -> dict | None:
    result = subprocess.run(
        ["gh", "release", "view", tag, "--json", "isDraft,url"],
        capture_output=True,
        text=True,
    )
    if result.returncode != 0:
        return None
    return json.loads(result.stdout)


def create_draft_release(tag: str, title: str, commit: str) -> None:
    notes = textwrap.dedent(
        """\
        Draft release generated by scripts/release.py.

        Populate the release notes before publishing.
        """
    )
    run(
        [
            "gh",
            "release",
            "create",
            tag,
            "--draft",
            "--title",
            title,
            "--notes",
            notes,
            "--target",
            commit,
        ]
    )


def ensure_draft_release(tag: str, title: str, commit: str) -> None:
    release = get_release(tag)
    if release:
        if not release.get("isDraft", False):
            sys.exit(
                f"Release {tag} already exists and is published. "
                "Delete it or bump the version before retrying."
            )
        print(f"Using existing draft release {tag}")
        return
    create_draft_release(tag, title, commit)


def ensure_rust_targets(targets: list[str]) -> None:
    for target in targets:
        run(["rustup", "target", "add", target])


def detect_host_triple() -> str:
    rustc_info = subprocess.run(
        ["rustc", "-vV"], check=True, capture_output=True, text=True
    ).stdout
    for line in rustc_info.splitlines():
        if line.startswith("host:"):
            return line.split(":", 1)[1].strip()
    sys.exit("Unable to detect rustc host triple.")


def determine_build_command(target: str, host: str) -> list[str]:
    if target == host:
        return ["cargo", "build", "--release", "--target", target]

    if target.endswith("apple-darwin") and "apple-darwin" not in host:
        raise RuntimeError(
            f"Target {target} requires running the script on macOS. "
            "Re-run on a macOS host."
        )

    if target.endswith("pc-windows-msvc") and "windows-msvc" not in host:
        raise RuntimeError(
            f"Target {target} requires MSVC tooling. "
            "Run the release script on a Windows machine with the Visual Studio Build Tools installed."
        )

    if target.endswith("unknown-linux-gnu") and "linux-gnu" not in host:
        if shutil.which("cargo-zigbuild"):
            return ["cargo", "zigbuild", "--release", "--target", target]
        if shutil.which("cross"):
            return ["cross", "build", "--release", "--target", target]
        raise RuntimeError(
            f"Target {target} needs additional cross-compilation tooling. "
            "Install `cargo-zigbuild` (recommended) or `cross`, or run the script on a Linux host."
        )

    return ["cargo", "build", "--release", "--target", target]


def order_targets(targets: list[str], host: str) -> list[str]:
    def priority(target: str) -> tuple[int, str]:
        if target == host:
            return (0, target)
        if "apple-darwin" in host and target.endswith("apple-darwin"):
            return (1, target)
        if target.endswith("unknown-linux-gnu"):
            return (2, target)
        return (3, target)

    return sorted(targets, key=priority)


def build_release_binaries(targets: list[str], host: str) -> tuple[list[str], list[tuple[str, str]]]:
    built: list[str] = []
    skipped: list[tuple[str, str]] = []
    for target in order_targets(targets, host):
        try:
            cmd = determine_build_command(target, host)
        except RuntimeError as exc:
            skipped.append((target, str(exc)))
            continue
        run(cmd)
        built.append(target)
    return built, skipped


def files_to_package(bin_names: list[str], target: str) -> list[Path]:
    release_dir = ROOT / "target" / target / "release"
    suffix = ".exe" if "windows" in target else ""
    binaries = []
    for bin_name in bin_names:
        candidate = release_dir / f"{bin_name}{suffix}"
        if not candidate.exists():
            sys.exit(f"Expected build artifact missing: {candidate}")
        binaries.append(candidate)

    extras = []
    for extra in ("README.md", "LICENSE", "LICENSE-MIT", "LICENSE-APACHE"):
        extra_path = ROOT / extra
        if extra_path.exists():
            extras.append(extra_path)

    return binaries + extras


def package_artifacts(
    package_name: str, version: str, bin_names: list[str], targets: list[str]
) -> list[Path]:
    DIST_DIR.mkdir(parents=True, exist_ok=True)
    artifacts: list[Path] = []
    for target in targets:
        archive_base = f"{package_name}-{version}-{target}"
        archive_path: Path
        files = files_to_package(bin_names, target)

        with TemporaryDirectory() as tmp_dir_str:
            tmp_dir = Path(tmp_dir_str)
            for file_path in files:
                shutil.copy2(file_path, tmp_dir / file_path.name)

            if "windows" in target:
                archive_path = DIST_DIR / f"{archive_base}.zip"
                with zipfile.ZipFile(
                    archive_path, mode="w", compression=zipfile.ZIP_DEFLATED
                ) as zipf:
                    for file_path in tmp_dir.iterdir():
                        zipf.write(file_path, arcname=file_path.name)
            else:
                archive_path = DIST_DIR / f"{archive_base}.tar.gz"
                with tarfile.open(archive_path, mode="w:gz") as tarf:
                    for file_path in tmp_dir.iterdir():
                        tarf.add(file_path, arcname=file_path.name)

        artifacts.append(archive_path)
        print(f"Packaged {archive_path}")

    return artifacts


def upload_artifacts(tag: str, artifacts: list[Path]) -> None:
    for artifact in artifacts:
        run(["gh", "release", "upload", tag, str(artifact), "--clobber"])


def open_release_in_browser(tag: str) -> None:
    result = subprocess.run(
        ["gh", "release", "view", tag, "--json", "url", "--jq", ".url"],
        check=True,
        capture_output=True,
        text=True,
    )
    url = result.stdout.strip()
    if not url:
        print("Release URL not found; open the draft manually.")
        return
    print(f"Opening {url}")
    if not webbrowser.open(url):
        print("Unable to launch browser automatically; open the URL above.")


def main() -> None:
    os.chdir(ROOT)
    extend_path()
    ensure_tools_available()

    manifest = read_manifest()
    package = manifest["package"]
    package_name = package["name"]
    version = package["version"]
    tag = f"v{version}"

    targets = collect_targets(manifest)
    bin_names = collect_binaries(manifest)

    commit = current_commit()
    ensure_draft_release(tag, f"{package_name} {version}", commit)
    ensure_rust_targets(targets)
    host = detect_host_triple()
    built_targets, skipped_targets = build_release_binaries(targets, host)
    if not built_targets:
        sys.exit("No targets were built. Resolve the issues above and retry.")

    artifacts = package_artifacts(package_name, version, bin_names, built_targets)
    upload_artifacts(tag, artifacts)
    open_release_in_browser(tag)

    if skipped_targets:
        print("The following targets were skipped:")
        for target, reason in skipped_targets:
            print(f"  - {target}: {reason}")


if __name__ == "__main__":
    try:
        main()
    except subprocess.CalledProcessError as exc:
        sys.exit(exc.returncode)
